Bora falar das **estruturas de controle** no Go, Victor! üöÄ S√£o os comandos que v√£o te permitir tomar decis√µes e repetir tarefas no seu c√≥digo. Isso inclui **condicionais** (como `if-else`, `switch`) e **loops** (como `for`). A boa not√≠cia √© que o Go √© bem simples e direto quando o assunto √© controle de fluxo. Vamos dar uma olhada em cada uma dessas estruturas!

---

### 1. **Condicionais (If-Else)** üß†
O famoso **`if-else`** √© o b√°sico para fazer o c√≥digo tomar decis√µes. A sintaxe √© praticamente igual a outras linguagens, mas com uma diferen√ßa: **n√£o precisa de par√™nteses** em volta da condi√ß√£o! üòé

#### Sintaxe B√°sica:
```go
if condi√ß√£o {
    // c√≥digo executado se a condi√ß√£o for verdadeira
} else {
    // c√≥digo executado se a condi√ß√£o for falsa
}
```

#### Exemplo:
```go
idade := 23

if idade >= 18 {
    fmt.Println("Maior de idade!")
} else {
    fmt.Println("Menor de idade!")
}
```

#### If com Inicializa√ß√£o (aquele truquezinho legal!) üöÄ
Voc√™ pode declarar uma vari√°vel no pr√≥prio `if`:
```go
if idade := 23; idade >= 18 {
    fmt.Println("Pode entrar!")
}
```
Aqui, a vari√°vel `idade` √© declarada **dentro do pr√≥prio `if`** e √© usada apenas ali.

---

### 2. **Switch-Case** üéØ
O `switch` no Go √© bem poderoso. Ele pode substituir uma s√©rie de `if-else` e tem algumas funcionalidades bem legais. Diferente de outras linguagens, no Go **n√£o precisa de `break`**, ele j√° encerra a execu√ß√£o ap√≥s o primeiro caso verdadeiro.

#### Sintaxe B√°sica:
```go
switch vari√°vel {
case valor1:
    // c√≥digo executado se vari√°vel == valor1
case valor2:
    // c√≥digo executado se vari√°vel == valor2
default:
    // c√≥digo executado se nenhum caso for verdadeiro
}
```

#### Exemplo:
```go
dia := "ter√ßa"

switch dia {
case "segunda":
    fmt.Println("Come√ßo de semana!")
case "sexta":
    fmt.Println("Sextou!")
default:
    fmt.Println("Mais um dia comum.")
}
```

#### **Switch sem Express√£o** üî•
Voc√™ pode usar um `switch` sem passar uma vari√°vel, fazendo com que ele teste v√°rias condi√ß√µes diretamente:
```go
idade := 23

switch {
case idade < 12:
    fmt.Println("Crian√ßa")
case idade < 18:
    fmt.Println("Adolescente")
default:
    fmt.Println("Adulto")
}
```

---

### 3. **For (Loops)** üîÑ
**N√£o existe `while` no Go**, mas o **`for`** faz tudo! üé©‚ú® Ele √© super vers√°til e pode ser usado como `while` ou como o bom e velho `for` das outras linguagens.

#### Sintaxe B√°sica do `For`:
```go
for inicializa√ß√£o; condi√ß√£o; p√≥s-execu√ß√£o {
    // c√≥digo que ser√° repetido enquanto a condi√ß√£o for verdadeira
}
```

#### Exemplo:
```go
for i := 0; i < 5; i++ {
    fmt.Println(i)
}
```
Esse exemplo vai imprimir os n√∫meros de 0 a 4.

#### **For como While** üîÑ
Quando voc√™ n√£o precisa de uma inicializa√ß√£o ou p√≥s-execu√ß√£o, o `for` funciona como um `while`:
```go
idade := 15

for idade < 18 {
    fmt.Println("Ainda menor de idade:", idade)
    idade++
}
```
Aqui, ele vai rodar enquanto a condi√ß√£o `idade < 18` for verdadeira.

#### **Loop Infinito** üîÅ
Quer um loop que nunca acaba (a menos que voc√™ o interrompa manualmente)? √â s√≥ usar `for` sem condi√ß√£o:
```go
for {
    fmt.Println("Rodando infinitamente...")
    break  // sem isso aqui, o loop nunca para!
}
```

#### **For sobre Arrays e Slices** üçï
Voc√™ pode usar o `for` com **`range`** para iterar sobre arrays, slices, mapas, ou at√© strings:
```go
frutas := []string{"banana", "ma√ß√£", "laranja"}

for indice, fruta := range frutas {
    fmt.Printf("%d: %s\n", indice, fruta)
}
```
Aqui, o `range` retorna dois valores: o √≠ndice e o valor em cada itera√ß√£o.

Se voc√™ n√£o precisa do √≠ndice, pode ignor√°-lo:
```go
for _, fruta := range frutas {
    fmt.Println(fruta)
}
```

---

### 4. **Break e Continue** üõë

#### **Break** ‚Äì Parar o loop üîö
O `break` encerra o loop imediatamente, pulando para fora dele:
```go
for i := 0; i < 10; i++ {
    if i == 5 {
        break  // para o loop quando i for 5
    }
    fmt.Println(i)
}
```

#### **Continue** ‚Äì Pular para a pr√≥xima itera√ß√£o ‚è©
O `continue` pula para a pr√≥xima itera√ß√£o do loop, ignorando o restante do c√≥digo na itera√ß√£o atual:
```go
for i := 0; i < 10; i++ {
    if i%2 == 0 {
        continue  // pula n√∫meros pares
    }
    fmt.Println(i)
}
```

---

### 5. **Labels com Break e Continue** üöÄ
No Go, voc√™ pode usar **labels** para controlar em qual loop voc√™ quer aplicar um `break` ou `continue`. Isso √© √∫til quando voc√™ tem loops aninhados.

#### Exemplo com `break` e label:
```go
outerLoop:
for i := 0; i < 5; i++ {
    for j := 0; j < 5; j++ {
        if i+j > 6 {
            break outerLoop  // sai de ambos os loops!
        }
        fmt.Printf("i=%d, j=%d\n", i, j)
    }
}
```
Aqui, quando a soma de `i` e `j` for maior que 6, ele vai quebrar o loop externo, gra√ßas ao label `outerLoop`.

---

### 6. **Condicionais e Loops Avan√ßados** üöÄ

#### **Condicional dentro de um loop**:
Voc√™ pode combinar condicionais dentro de loops para tomar decis√µes durante cada itera√ß√£o:
```go
for i := 1; i <= 10; i++ {
    if i%2 == 0 {
        fmt.Printf("%d √© par\n", i)
    } else {
        fmt.Printf("%d √© √≠mpar\n", i)
    }
}
```

#### **Loop Aninhado**:
Voc√™ tamb√©m pode ter loops dentro de loops para trabalhar com estruturas mais complexas:
```go
for i := 1; i <= 3; i++ {
    for j := 1; j <= 3; j++ {
        fmt.Printf("%d x %d = %d\n", i, j, i*j)
    }
}
```
Esse c√≥digo imprime uma mini tabuada para os n√∫meros de 1 a 3.

---

### Resumo üéâ

- **If-Else**: Toma decis√µes com base em condi√ß√µes.
- **Switch**: Um jeito elegante de lidar com m√∫ltiplas condi√ß√µes.
- **For**: √â o loop universal no Go. Pode ser usado como loop cl√°ssico ou enquanto (`while`).
- **Break e Continue**: Controle sobre loops ‚Äì para parar ou pular itera√ß√µes.
- **Range**: Uma forma pr√°tica de iterar sobre arrays, slices, mapas, ou strings.

---

### üåê Navega√ß√£o entre os arquivos:

- [‚¨ÖÔ∏è 5. INOUT.md](https://github.com/atenatt/guia-devops/blob/main/programacao/golang/5.%20INOUT.md) | | [‚û°Ô∏è 7. CONCEITOS.md](https://github.com/atenatt/guia-devops/blob/main/programacao/golang/7.%20CONCEITOS.md)